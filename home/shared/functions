#!/usr/bin/env bash

TINTY_FZF="$HOME/.local/share/tinted-theming/tinty/tinted-fzf-sh-file.sh"

tinty_source_shell_theme() {
  local tinty_data_dir="${XDG_DATA_HOME:-$HOME/.local/share}/tinted-theming/tinty"

  if [[ "$1" == "init" ]]; then
    tinty "$@"
    while IFS= read -r script; do
      . "$script"
    done < <(find "$tinty_data_dir" -maxdepth 1 -name "*.sh")
  elif [[ "$1" == "apply" ]]; then
    local newer_file
    newer_file=$(mktemp)
    tinty "$@"
    while IFS= read -r script; do
      . "$script"
    done < <(find "$tinty_data_dir" -maxdepth 1 -name "*.sh" -newer "$newer_file")
    rm -f "$newer_file"
  else
    tinty "$@"
  fi
}

theme() {
  local selected
  [ -f $TINTY_FZF ] && . $TINTY_FZF
  selected=$(tinty list | fzf-tmux -p 70%,70% --preview 'tinty info {}')
  if [[ -n "$selected" ]]; then
    tinty_source_shell_theme apply "$selected"
  fi
}

# Zsh-specific function for updating oh-my-zsh custom plugins/themes
update_custom_oh_my_zsh() {
  example='example'
  custom_type=$1
  for custom_plugin_or_theme in $ZSH/custom/$custom_type/*; do
    if test "${custom_plugin_or_theme#*$example}" = "$custom_plugin_or_theme"; then
      printf "Upgrading %s...\n" "$custom_plugin_or_theme"
      cd "$custom_plugin_or_theme" && git pull --stat && cd - || return
    fi
  done
}

# Zsh-specific update function
update() {
  tinty update
  update_custom_oh_my_zsh 'plugins'
  update_custom_oh_my_zsh 'themes'
  omz update
}

tmux() {
  case $1 in
  start)
    if [[ -n "$TMUX" ]]; then
      command tmux new-session -d -s "$2"
      command tmux rename-window -t "$2:0" Terminal
      command tmux new-window -t "$2" -n Editor
      command tmux new-window -t "$2" -n Server
      command tmux select-window -t "$2:0"
      command tmux switch-client -t "$2"
    else
      command tmux new-session -s "$2"
      command tmux rename-window -t "$2:0" Terminal
      command tmux new-window -t "$2" -n Editor
      command tmux new-window -t "$2" -n Server
      command tmux select-window -t "$2:0"
    fi
    ;;
  *)
    command tmux "$@"
    ;;
  esac
}

killport() {
  lsof -i "tcp:$1" | awk 'NR!=1 {print $2}' | xargs kill -9
}

branch() {
  if git rev-parse --git-dir &>/dev/null; then
    branch=$(git for-each-ref --color --sort=-committerdate \
      refs/heads/ \
      --format='%(HEAD) %(color:yellow)%(refname:short)%(color:reset) | (%(color:green)%(committerdate:relative)%(color:reset)) %(color:bold)%(authorname)%(color:reset) - %(contents:subject)' |
      fzf --ansi |
      cut -f1 -d'|' |
      xargs)

    if [[ -n "$branch" ]]; then
      git checkout "$branch"
    fi
  else
    echo 'ERROR: Not a git repository'
  fi
}

cob() {
  if git rev-parse --git-dir &>/dev/null; then
    branch=$(git branch --color --sort=-committerdate \
      --format='%(HEAD) %(color:yellow)%(refname:short)%(color:reset) | (%(color:green)%(committerdate:relative)%(color:reset)) %(color:bold)%(authorname)%(color:reset) - %(contents:subject)' -r |
      fzf --ansi |
      sed "s/origin\\///g" |
      cut -f1 -d'|' |
      xargs)

    if [[ -n "$branch" ]]; then
      git checkout "$branch"
    fi
  else
    echo 'ERROR: Not a git repository'
  fi
}

upstream() {
  branch=$(git rev-parse --abbrev-ref HEAD)
  if [[ -n "$branch" ]]; then
    git branch --set-upstream-to="origin/$branch" "$branch"
  fi
}

lg() {
  export LAZYGIT_NEW_DIR_FILE=~/.lazygit/newdir

  lazygit "$@"

  if [[ -f "$LAZYGIT_NEW_DIR_FILE" ]]; then
    cd "$(cat "$LAZYGIT_NEW_DIR_FILE")" || return
    rm -f "$LAZYGIT_NEW_DIR_FILE" &>/dev/null
  fi
}

tig() {
  command tig "$@" --pretty=fuller
}

y() {
  local tmp cwd
  tmp="$(mktemp -t "yazi-cwd.XXXXXX")"
  yazi "$@" --cwd-file="$tmp"
  if cwd="$(command cat -- "$tmp")" && [[ -n "$cwd" ]] && [[ "$cwd" != "$PWD" ]]; then
    builtin cd -- "$cwd" || return
  fi
  rm -f -- "$tmp"
}

how() {
  local input="$*"
  local escaped_input
  escaped_input=$(printf '%s' "$input" | jq -Rs .)

  if [[ -f /opt/dev/bin/dev ]]; then
    curl -s https://proxy-shopify-ai.local.shop.dev/v1/chat/completions \
      -H "Content-Type: application/json" \
      -d "$(jq -n --argjson content "$escaped_input" '{
        "model": "expensive-but-best",
        "messages": [
          {"role": "system", "content": "You are a concise cheat sheet. Provide ONLY the shortest possible answer - just the command, key combination, or flag needed. No explanations, no context, no formatting. Just the raw answer. Pay attention to proper case sensitivity (uppercase/lowercase)."},
          {"role": "user", "content": $content}
        ]
      }')" | jq -r '.choices[0].message.content'
  else
    claude -p "$input" --model haiku --append-system-prompt "You are a concise cheat sheet. Provide ONLY the shortest possible answer - just the command, key combination, or flag needed. No explanations, no context, no formatting. Just the raw answer."
  fi
}

# Tinty initialization (only run in interactive shells, not in nvim/floaterm)
if command -v tinty &>/dev/null; then
  case $- in
  *i*)
    if [[ -z "$FLOATERM" ]] && [[ -z "$NVIM" ]]; then
      # Detect shell type for completion generation
      if [[ -n "$BASH_VERSION" ]]; then
        eval "$(tinty generate-completion bash)"
      elif [[ -n "$ZSH_VERSION" ]]; then
        eval "$(tinty generate-completion zsh)"
        compdef tinty_source_shell_theme=tinty
      fi
      alias tinty=tinty_source_shell_theme
      tinty_source_shell_theme "init" &>/dev/null
    fi
    ;;
  esac
fi
